using Unity.Mathematics;
using UnityEngine;
using UnityEngine.Serialization;

public class PlanetGenMain : MonoBehaviour
{
    [Header("Field")] public int fieldWidth = 512;
    [Range(0, 0.5f)] public float radius = 0.5f;
    [Range(0, 2f)] public float amplitude = 0.5f;
    [Range(0, 10f)] public float frequency = 0.5f;

    [Header("Marching Squares")] public ComputeShader marchingSquaresShader;
    public ComputeShader segmentsToQuadsShader;
    public ComputeShader indirectArgsShader;
    public Material material;
    public float quadSize = 1f; // Larger for visibility
    public float iso = 0.5f;
    public float lineWidth;
    
    private ComputeBuffer segmentColorBuffer;
    private ComputeBuffer segmentBuffer;
    private ComputeBuffer vertexBuffer;
    private ComputeBuffer vertexColorBuffer;
    private ComputeBuffer segmentCountBuffer;
    private ComputeBuffer indirectArgsBuffer;
    private int vertexCount;

    private FieldGen fieldGen;

    [FormerlySerializedAs("renderer")] public Renderer fieldRenderer;

    //-------

    private ComputePipeline computePipeline;
    private RenderPipeline renderPipeline;
    
    // public void Start()
    // {
    //     Do();
    // }

    void Do()
    {
        // Field
        FieldGen.TextureRegistry textures = new FieldGen.TextureRegistry(fieldWidth);
        fieldGen = new FieldGen();
        fieldGen.GetTex(textures, 0, radius, amplitude, frequency, fieldWidth);

        fieldRenderer.material.SetTexture("_FieldTex", textures.fields);
        fieldRenderer.material.SetTexture("_ColorTex",  textures.colors);

        // Buffers
        int maxSegments = (fieldWidth - 1) * (fieldWidth - 1) * 4;
        print($"max Segments: {maxSegments}");
        
        segmentBuffer = new ComputeBuffer(maxSegments, sizeof(float) * 4, ComputeBufferType.Default);
        Vector4[] emptySegments = new Vector4[maxSegments]; // This creates an array of Vector4.zero
        segmentBuffer.SetData(emptySegments);
        
        segmentColorBuffer = new ComputeBuffer(maxSegments, sizeof(float) * 8, ComputeBufferType.Default);

        Vector4[] emptyculaz = new Vector4[maxSegments * 2];
        
        segmentColorBuffer.SetData(emptyculaz);
        
        segmentCountBuffer = new ComputeBuffer(1, sizeof(int), ComputeBufferType.Raw);
        segmentCountBuffer.SetData(new int[1] { 0 });
        
        vertexColorBuffer = new ComputeBuffer(maxSegments * 6, sizeof(float) * 4);
        vertexCount = maxSegments * 6; // 6 vertices per segment (2 triangles)
        float4[] dummyColors = new float4[vertexCount];
        for (int i = 0; i < dummyColors.Length; i++)
        {
            dummyColors[i] = new float4(0f, 0f, 0f, 0f); // Black color
        }
        vertexColorBuffer.SetData(dummyColors);
        
        vertexBuffer = new ComputeBuffer(vertexCount, sizeof(float) * 3);
        Vector3[] dummyVerts = new Vector3[vertexCount];
        for (int i = 0; i < dummyVerts.Length; i++)
        {
            dummyVerts[i] = new Vector3(0f, 0f, 0f); // Origin point
        }
        vertexBuffer.SetData(dummyVerts);
        
        // Marching Squares
        int marchingKernel = marchingSquaresShader.FindKernel("MarchingSquares");
        
        marchingSquaresShader.SetBuffer(marchingKernel, "SegmentsBuffer", segmentBuffer);
        marchingSquaresShader.SetBuffer(marchingKernel, "SegmentCountBuffer", segmentCountBuffer);
        marchingSquaresShader.SetBuffer(marchingKernel, "SegmentColorsBuffer", segmentColorBuffer);
        marchingSquaresShader.SetFloat("IsoValue", iso);
        marchingSquaresShader.SetInt("TextureHeight", fieldWidth);
        marchingSquaresShader.SetInt("TextureWidth", fieldWidth);
        marchingSquaresShader.SetTexture(marchingKernel, "ScalarFieldTexture", textures.fields);
        marchingSquaresShader.SetTexture(marchingKernel, "ColorFieldTexture", textures.colors);
        
        int threadGroups = Mathf.CeilToInt(fieldWidth / 8f);
        marchingSquaresShader.Dispatch(marchingKernel, threadGroups, threadGroups, 1);

        int quadKernel = segmentsToQuadsShader.FindKernel("CSMain");
        

        
        indirectArgsBuffer = new ComputeBuffer(3, sizeof(int), ComputeBufferType.IndirectArguments);
        indirectArgsBuffer.SetData(new int[3] { 0, 1, 1 });
        
        int prepareArgsKernel = indirectArgsShader.FindKernel("PrepareIndirectArgs");
        int threadGroupSize = 64;
        indirectArgsShader.SetInt("ThreadGroupSize", threadGroupSize);
        indirectArgsShader.SetBuffer(prepareArgsKernel, "SegmentCountBuffer", segmentCountBuffer);
        indirectArgsShader.SetBuffer(prepareArgsKernel, "IndirectArgsBuffer", indirectArgsBuffer);
        indirectArgsShader.Dispatch(prepareArgsKernel, 1, 1, 1);
        
        
        segmentsToQuadsShader.SetBuffer(quadKernel, "segmentBuffer", segmentBuffer);
        segmentsToQuadsShader.SetBuffer(quadKernel, "segmentColorBuffer", segmentColorBuffer);
        segmentsToQuadsShader.SetBuffer(quadKernel, "vertexBuffer", vertexBuffer);
        segmentsToQuadsShader.SetBuffer(quadKernel, "vertexColorBuffer", vertexColorBuffer);
        segmentsToQuadsShader.SetBuffer(quadKernel, "segmentCountBuffer", segmentCountBuffer);
        segmentsToQuadsShader.SetFloat("lineWidth", 0.005f);
        segmentsToQuadsShader.DispatchIndirect(quadKernel, indirectArgsBuffer);
        
        
        material.SetBuffer("VertexBuffer", vertexBuffer);
        material.SetBuffer("VertexColorBuffer", vertexColorBuffer);
    }
    
    
    

    


    // public void Update()
    // {
    //     if (vertexBuffer != null && material != null)
    //     {
    //         // Larger bounds to ensure visibility
    //         Bounds bounds = new Bounds(Vector3.zero, Vector3.one * 50f);
    //
    //         // Graphics.DrawProcedural(material, bounds, MeshTopology.Triangles, vertexCount);
    //         Graphics.DrawProcedural(material, bounds, MeshTopology.Triangles, vertexBuffer.count);
    //     }
    //     else
    //     {
    //         print("Vertex Buffer or Material is null");
    //     }
    // }


    void OnDestroy()
    {
        vertexBuffer?.Release();
        vertexColorBuffer?.Release();
    }


    /// ///////////////////////// old way above



    void Start()
    {
        InitPipeline();
        RegenAll();
    }

    void Update()
    {
        computePipeline?.DebugDraw();
        renderPipeline?.Render();

    }

    public void RegenAll()
    {
        GenerateField();
        ExecuteComputePipeline();
    }

    void InitPipeline()
    {
        fieldGen = new FieldGen();
        computePipeline = new ComputePipeline(this);
        renderPipeline = new RenderPipeline(this);
    }

    void GenerateField()
    {
        var textures = new FieldGen.TextureRegistry(fieldWidth);
        fieldGen.GetTex(textures, 0, radius, amplitude, frequency, fieldWidth);
        fieldRenderer.material.SetTexture("_FieldTex", textures.fields);
        fieldRenderer.material.SetTexture("_ColorTex", textures.colors);
        computePipeline.SetFieldTextures(textures.fields, textures.colors);
    }

    void ExecuteComputePipeline()
    {
        computePipeline.Execute(fieldWidth, iso, lineWidth);
        renderPipeline.UpdateBuffers(computePipeline.RenderBufferRegistry);
    }

    Vector3[] SegmentsToVerts(Vector4[] segments)
    {
        // Filter out empty segments (segments with zero length or invalid data)
        var validSegments = new System.Collections.Generic.List<Vector4>();

        for (int i = 0; i < segments.Length; i++)
        {
            Vector4 segment = segments[i];
            Vector3 start = new Vector3(segment.x, segment.y, 0);
            Vector3 end = new Vector3(segment.z, segment.w, 0);

            // Skip segments with zero length or invalid coordinates
            if (Vector3.Distance(start, end) > 0.001f &&
                !float.IsNaN(segment.x) && !float.IsNaN(segment.y) &&
                !float.IsNaN(segment.z) && !float.IsNaN(segment.w))
            {
                validSegments.Add(segment);
            }
        }

        // Each segment becomes a quad (2 triangles = 6 vertices)
        Vector3[] vertices = new Vector3[validSegments.Count * 6];
        float lineWidth = 0.005f; // Adjust this to control line thickness

        for (int i = 0; i < validSegments.Count; i++)
        {
            Vector4 segment = validSegments[i];
            Vector3 start = new Vector3(segment.x, segment.y, 0);
            Vector3 end = new Vector3(segment.z, segment.w, 0);

            // Calculate perpendicular direction for line width
            Vector3 direction = (end - start).normalized;
            Vector3 perpendicular = new Vector3(-direction.y, direction.x, 0) * lineWidth * 0.5f;

            // Calculate quad corners
            Vector3 bl = start - perpendicular; // bottom-left
            Vector3 tl = start + perpendicular; // top-left  
            Vector3 br = end - perpendicular; // bottom-right
            Vector3 tr = end + perpendicular; // top-right

            // First triangle: bl, tl, br
            int vertexIndex = i * 6;
            vertices[vertexIndex + 0] = bl;
            vertices[vertexIndex + 1] = tl;
            vertices[vertexIndex + 2] = br;

            // Second triangle: br, tl, tr
            vertices[vertexIndex + 3] = br;
            vertices[vertexIndex + 4] = tl;
            vertices[vertexIndex + 5] = tr;
        }

        return vertices;
    }
    
    private class ComputePipeline : System.IDisposable
    {
        private readonly PlanetGenMain parent;
        private ComputeBuffer segmentBuffer;
        private ComputeBuffer segmentColorBuffer;
        private ComputeBuffer vertexBuffer;
        private ComputeBuffer vertexColorBuffer;
        private ComputeBuffer segmentCountBuffer;
        private ComputeBuffer indirectArgsBuffer;

        private Texture2D fieldTexture;
        private Texture2D colorTexture;

        private int maxSegments;
        private bool isInitted;

        public ComputePipeline(PlanetGenMain parent)
        {
            this.parent = parent;
        }

        public void Execute(int fieldWidth, float isoValue, float lineWidth)
        {
            InitBuffers(fieldWidth);
            ComputeMarchingSquares(fieldWidth, isoValue);
            ComputeSegmentsToQuads(lineWidth);
        }

        void InitBuffers(int fieldWidth)
        {
            int newMaxSegments = (fieldWidth - 1) * (fieldWidth - 1) * 4;

            if (isInitted && newMaxSegments == maxSegments) return;

            DisposeBuffers();
            maxSegments = newMaxSegments;

            try
            {
                segmentBuffer = new ComputeBuffer(maxSegments, sizeof(float) * 4);
                segmentColorBuffer = new ComputeBuffer(maxSegments, sizeof(float) * 8);
                segmentCountBuffer =
                    new ComputeBuffer(1, sizeof(int), ComputeBufferType.Raw); // raw for atomic operations
                vertexBuffer = new ComputeBuffer(maxSegments * 6, sizeof(float) * 3);
                vertexColorBuffer = new ComputeBuffer(maxSegments * 6, sizeof(float) * 4);
                indirectArgsBuffer = new ComputeBuffer(3, sizeof(int), ComputeBufferType.IndirectArguments);

                // init with empty data
                segmentBuffer.SetData(new Vector4[maxSegments]);
                segmentColorBuffer.SetData(new Vector4[maxSegments * 2]);
                segmentCountBuffer.SetData(new[] { 0 });
                vertexBuffer.SetData(new Vector3[maxSegments * 6]);
                vertexColorBuffer.SetData(new Vector4[maxSegments * 6]);
                indirectArgsBuffer.SetData(new[] { 0, 1, 1 });

                isInitted = true;
            }
            catch (System.Exception e)
            {
                Debug.LogError($"Failed to initialize compute buffers: {e.Message}");
                DisposeBuffers();
                throw;
            }
        }

        void ComputeMarchingSquares(int fieldWidth, float isoValue)
        {
            if (!parent.marchingSquaresShader || fieldTexture == null) return;

            int kernel = parent.marchingSquaresShader.FindKernel("MarchingSquares");

            parent.marchingSquaresShader.SetBuffer(kernel, "SegmentsBuffer", segmentBuffer);
            parent.marchingSquaresShader.SetBuffer(kernel, "SegmentCountBuffer", segmentCountBuffer);
            parent.marchingSquaresShader.SetBuffer(kernel, "SegmentColorsBuffer", segmentColorBuffer);
            parent.marchingSquaresShader.SetFloat("IsoValue", isoValue);
            parent.marchingSquaresShader.SetInt("TextureHeight", fieldWidth);
            parent.marchingSquaresShader.SetInt("TextureWidth", fieldWidth);
            parent.marchingSquaresShader.SetTexture(kernel, "ScalarFieldTexture", fieldTexture);
            parent.marchingSquaresShader.SetTexture(kernel, "ColorFieldTexture", colorTexture);

            int threadGroups = Mathf.CeilToInt(fieldWidth / 8f);
            parent.marchingSquaresShader.Dispatch(kernel, threadGroups, threadGroups, 1);
        }

        void ComputeSegmentsToQuads(float lineWidth)
        {
            if (!parent.indirectArgsShader) return;

            int argKernel = parent.indirectArgsShader.FindKernel("PrepareIndirectArgs");
            parent.indirectArgsShader.SetInt("ThreadGroupSize", 64);
            parent.indirectArgsShader.SetBuffer(argKernel, "SegmentCountBuffer", segmentCountBuffer);
            parent.indirectArgsShader.SetBuffer(argKernel, "IndirectArgsBuffer", indirectArgsBuffer);
            parent.indirectArgsShader.Dispatch(argKernel, 1, 1, 1);


            if (!parent.segmentsToQuadsShader) return;

            int seg2QuadKernel = parent.segmentsToQuadsShader.FindKernel("CSMain");
            parent.segmentsToQuadsShader.SetBuffer(seg2QuadKernel, "segmentBuffer", segmentBuffer);
            parent.segmentsToQuadsShader.SetBuffer(seg2QuadKernel, "segmentColorBuffer", segmentColorBuffer);
            parent.segmentsToQuadsShader.SetBuffer(seg2QuadKernel, "vertexBuffer", vertexBuffer);
            parent.segmentsToQuadsShader.SetBuffer(seg2QuadKernel, "vertexColorBuffer", vertexColorBuffer);
            parent.segmentsToQuadsShader.SetBuffer(seg2QuadKernel, "segmentCountBuffer", segmentCountBuffer);
            parent.segmentsToQuadsShader.SetFloat("lineWidth", lineWidth);
            parent.segmentsToQuadsShader.DispatchIndirect(seg2QuadKernel, indirectArgsBuffer);
        }

        public void SetFieldTextures(Texture2D field, Texture2D color)
        {
            fieldTexture = field;
            colorTexture = color;
        }

        public RenderBufferRegistry RenderBufferRegistry =>
            new RenderBufferRegistry(vertexBuffer, vertexColorBuffer);


        public void DebugDraw()
        {
            if (segmentBuffer != null)
            {
                Vector4[] segments = new Vector4[segmentBuffer.count];
                segmentBuffer.GetData(segments);
            
                for (int i = 0; i < segments.Length; i++)
                {
                    Vector4 segment = segments[i];
                    Vector3 startPoint = new Vector3(segment.x, segment.y, 0);
                    Vector3 endPoint = new Vector3(segment.z, segment.w, 0);
            
                    Debug.DrawLine(startPoint, endPoint, Color.green, Time.deltaTime);
                }
            }
        }
        
        void DisposeBuffers()
        {
            segmentBuffer?.Release();
            segmentColorBuffer?.Release();
            vertexBuffer?.Release();
            vertexColorBuffer?.Release();
            segmentCountBuffer?.Release();
            indirectArgsBuffer?.Release();
        }

        public void Dispose()
        {
            DisposeBuffers();
            isInitted = false;
        }
    }

    private class RenderPipeline : System.IDisposable
    {
        private readonly PlanetGenMain parent;
        private RenderBufferRegistry currentBuffers;

        public RenderPipeline(PlanetGenMain parent)
        {
            this.parent = parent;
        }

        public void UpdateBuffers(RenderBufferRegistry buffers)
        {
            currentBuffers = buffers;

            if (parent.material != null)
            {
                parent.material.SetBuffer("VertexBuffer", currentBuffers.vertexBuffer);
                parent.material.SetBuffer("VertexColorBuffer", currentBuffers.vertexColorBuffer);
            }
        }

        public void Render()
        {
            if (!currentBuffers.Validate())
            {
                print("invalid buffers");
                return;
            }
            if (parent.material == null)
            {
                print("null material");
                return;
            }
            // if (Camera.current == null)
            // {
            //     print("null camera");
            //     return;
            // }


            var vertCount = currentBuffers.vertexBuffer.count;
            // Vector3[] verts = new Vector3[vertCount];
            // currentBuffers.vertexBuffer.GetData(verts);
            // foreach(var vert in verts)
            // {
            //     print(vert);
            // }

            Vector4[] colors = new Vector4[vertCount];
            currentBuffers.vertexColorBuffer.GetData(colors);
            foreach(var color in colors)
                print(color);

            try
            {
                print(currentBuffers.vertexBuffer.count);
                Bounds bounds = new Bounds(Vector3.zero, Vector3.one * 50f); //todo remove magic number
                Graphics.DrawProcedural(parent.material, bounds, MeshTopology.Triangles,
                    currentBuffers.vertexBuffer.count);
            }
            catch (System.Exception e)
            {
                Debug.LogWarning($"Render failed: {e.Message}");
            }
        }

        public void Dispose()
        {
            currentBuffers = null; // properly disposed in ComputePipeline
        }
    }

    private class RenderBufferRegistry
    {
        public ComputeBuffer vertexBuffer;
        public ComputeBuffer vertexColorBuffer;

        public RenderBufferRegistry(ComputeBuffer vertex, ComputeBuffer vertexColor)
        {
            vertexBuffer = vertex;
            vertexColorBuffer = vertexColor;
        }

        public bool Validate()
        {
            return (vertexBuffer != null) && (vertexColorBuffer != null);
        }
    }
}

// using Unity.Mathematics;
// using UnityEngine;
//
// public class PlanetGen : MonoBehaviour
// {
//     [Header("Field")] public int fieldWidth = 512;
//     [Range(0, 0.5f)] public float radius = 0.5f;
//     [Range(0, 2f)] public float amplitude = 0.5f;
//     [Range(0, 10f)] public float frequency = 0.5f;
//
//     [Header("Marching Squares")] public ComputeShader marchingSquaresShader;
//     public ComputeShader segmentsToQuadsShader;
//     public ComputeShader indirectArgsShader;
//     public Material material;
//     public float quadSize = 1f; // Larger for visibility
//     public float iso = 0.5f;
//
//     private ComputeBuffer segmentColorBuffer;
//     private ComputeBuffer segmentBuffer;
//     private ComputeBuffer vertexBuffer;
//     private ComputeBuffer vertexColorBuffer;
//     private ComputeBuffer segmentCountBuffer;
//     private ComputeBuffer indirectArgsBuffer;
//     private int vertexCount;
//
//     private FieldGen fieldGen;
//
//     public Renderer renderer;
//
//     
//     public struct SegmentColor
//     {
//         public Vector4 Color1;
//         public Vector4 Color2;
//
//         public SegmentColor(Vector4 color1, Vector4 color2)
//         {
//             this.Color1 = color1;
//             this.Color2 = color2;
//         }
//     }
//     public void Start()
//     {
//
//         
//         Do();
//         // GenerateAndRenderTestQuads();
//         
//     }
//
//     void Do()
//     {
//         // Field
//         FieldGen.TextureRegistry textures = new FieldGen.TextureRegistry(fieldWidth);
//         fieldGen = new FieldGen();
//         fieldGen.GetTex(textures, 0, radius, amplitude, frequency, fieldWidth);
//
//         renderer.material.SetTexture("_FieldTex", textures.fields);
//         renderer.material.SetTexture("_ColorTex",  textures.colors);
//
//         // Buffers
//         int maxSegments = (fieldWidth - 1) * (fieldWidth - 1) * 4;
//         print(maxSegments);
//         
//         segmentBuffer = new ComputeBuffer(maxSegments, sizeof(float) * 4, ComputeBufferType.Default);
//         Vector4[] emptySegments = new Vector4[maxSegments]; // This creates an array of Vector4.zero
//         segmentBuffer.SetData(emptySegments);
//         
//         segmentColorBuffer = new ComputeBuffer(maxSegments, sizeof(float) * 8, ComputeBufferType.Default);
//         SegmentColor[] emptyColors = new SegmentColor[maxSegments];
//         for (int i = 0; i < maxSegments; i++)
//         {
//             emptyColors[i] = new SegmentColor(Vector4.zero, Vector4.zero);
//         }
//         segmentColorBuffer.SetData(emptyColors);
//         
//         segmentCountBuffer = new ComputeBuffer(1, sizeof(int), ComputeBufferType.Raw);
//         segmentCountBuffer.SetData(new int[1] { 0 });
//         
//         vertexColorBuffer = new ComputeBuffer(maxSegments * 6, sizeof(float) * 4);
//         vertexCount = maxSegments * 6; // 6 vertices per segment (2 triangles)
//         float4[] dummyColors = new float4[maxSegments * 6];
//         for (int i = 0; i < dummyColors.Length; i++)
//         {
//             dummyColors[i] = new float4(0f, 0f, 0f, 0f); // Black color
//         }
//         vertexColorBuffer.SetData(dummyColors);
//         
//         vertexBuffer = new ComputeBuffer(maxSegments * 6, sizeof(float) * 3);
//         Vector3[] dummyVerts = new Vector3[maxSegments * 6];
//         for (int i = 0; i < dummyVerts.Length; i++)
//         {
//             dummyVerts[i] = new Vector3(0f, 0f, 0f); // Origin point
//         }
//         vertexBuffer.SetData(dummyVerts);
//         
//         // Marching Squares
//         int marchingKernel = marchingSquaresShader.FindKernel("MarchingSquares");
//         
//         marchingSquaresShader.SetBuffer(marchingKernel, "SegmentsBuffer", segmentBuffer);
//         marchingSquaresShader.SetBuffer(marchingKernel, "SegmentCountBuffer", segmentCountBuffer);
//         marchingSquaresShader.SetBuffer(marchingKernel, "SegmentColorsBuffer", segmentColorBuffer);
//         marchingSquaresShader.SetFloat("IsoValue", iso);
//         marchingSquaresShader.SetInt("TextureHeight", fieldWidth);
//         marchingSquaresShader.SetInt("TextureWidth", fieldWidth);
//         marchingSquaresShader.SetTexture(marchingKernel, "ScalarFieldTexture", textures.fields);
//         marchingSquaresShader.SetTexture(marchingKernel, "ColorFieldTexture", textures.colors);
//         
//         int threadGroups = Mathf.CeilToInt(fieldWidth / 8f);
//         marchingSquaresShader.Dispatch(marchingKernel, threadGroups, threadGroups, 1);
//         
//         var segments = new Vector4[segmentBuffer.count];
//         segmentBuffer.GetData(segments);
//         //Segments to Quads
//         int quadKernel = segmentsToQuadsShader.FindKernel("CSMain");
//         
//
//         
//         indirectArgsBuffer = new ComputeBuffer(3, sizeof(int), ComputeBufferType.IndirectArguments);
//         indirectArgsBuffer.SetData(new int[3] { 0, 1, 1 });
//         
//         int prepareArgsKernel = indirectArgsShader.FindKernel("PrepareIndirectArgs");
//         int threadGroupSize = 64;
//         indirectArgsShader.SetInt("ThreadGroupSize", threadGroupSize);
//         indirectArgsShader.SetBuffer(prepareArgsKernel, "SegmentCountBuffer", segmentCountBuffer);
//         indirectArgsShader.SetBuffer(prepareArgsKernel, "IndirectArgsBuffer", indirectArgsBuffer);
//         indirectArgsShader.Dispatch(prepareArgsKernel, 1, 1, 1);
//
//         // optional debug
//         int[] segmentCountData = new int[1];
//         segmentCountBuffer.GetData(segmentCountData);
//         print($"actual segments generated: {segmentCountData[0]}" );
//         int[] argsData = new int[3];
//         indirectArgsBuffer.GetData(argsData);
//         print($"Indirect dispatch args: [{argsData[0]}, {argsData[1]}, {argsData[2]}]");
//         
//         segmentsToQuadsShader.SetBuffer(quadKernel, "segmentBuffer", segmentBuffer);
//         segmentsToQuadsShader.SetBuffer(quadKernel, "segmentColorBuffer", segmentColorBuffer);
//         segmentsToQuadsShader.SetBuffer(quadKernel, "vertexBuffer", vertexBuffer);
//         segmentsToQuadsShader.SetBuffer(quadKernel, "vertexColorBuffer", vertexColorBuffer);
//         segmentsToQuadsShader.SetBuffer(quadKernel, "segmentCountBuffer", segmentCountBuffer);
//         segmentsToQuadsShader.SetFloat("lineWidth", 0.005f);
//         segmentsToQuadsShader.DispatchIndirect(quadKernel, indirectArgsBuffer);
//         
//         var verts = new Vector3[vertexBuffer.count];
//         vertexBuffer.GetData(verts);
//         
//         material.SetBuffer("VertexBuffer", vertexBuffer);
//         material.SetBuffer("VertexColorBuffer", vertexColorBuffer);
//     }
//     
//     
//     
//
//     void GenerateAndRenderTestQuads()
//     {
//         int quad_count = 10;
//         
//         // vertexCount = quad_count * 6;
//         // vertexBuffer = new ComputeBuffer(60, sizeof(float) * 3);
//         // vertexColorBuffer = new ComputeBuffer(60, sizeof(float) * 4);
//
//         
//         
//         int max_segments = (fieldWidth - 1) * (fieldWidth - 1) * 4;
//         vertexBuffer = new ComputeBuffer(max_segments * 6, sizeof(float) * 3);
//         vertexColorBuffer = new ComputeBuffer(max_segments * 6, sizeof(float) * 4);
//        
//         // int z = 60;
//         // vertexBuffer = new ComputeBuffer(z, sizeof(float) * 3);
//         // vertexColorBuffer = new ComputeBuffer(z, sizeof(float) * 4);
//         
//         
//
//         vertexColorBuffer.SetData(GenerateDummyColors(quad_count));
//
//
//         var quads = GenerateDummyQuads(quad_count);
//         vertexBuffer.SetData(quads);
//
//         material.SetBuffer("VertexBuffer", vertexBuffer);
//         material.SetBuffer("VertexColorBuffer", vertexColorBuffer);
//     }
//
//     Vector4[] GenerateDummySegments()
//     {
//         Vector4[] segments = new Vector4[4];
//         segments[0] = new Vector4(-0.5f, 0, 0.5f, 0);
//         segments[1] = new Vector4(0.5f, 0, 0, 0.5f);
//         segments[2] = new Vector4(0, 0.5f, -0.75f, 0.75f);
//         segments[3] = new Vector4(-0.75f, 0.75f, -0.75f, -0.75f);
//         return segments;
//     }
//
//
//     Vector3[] GenerateDummyQuads(int count)
//     {
//         Vector3[] verts = new Vector3[count * 6]; // 6 vertices per quad (2 triangles)
//         System.Random rand = new System.Random();
//
//         for (int i = 0; i < count; i++)
//         {
//             // Generate random quad corners
//             float minX = (float)(rand.NextDouble() * 2 - 1); // -1 to 1
//             float maxX = (float)(rand.NextDouble() * 2 - 1);
//             float minY = (float)(rand.NextDouble() * 2 - 1);
//             float maxY = (float)(rand.NextDouble() * 2 - 1);
//             float z = 0f;
//
//             // Ensure min/max are correct
//             if (minX > maxX)
//             {
//                 float temp = minX;
//                 minX = maxX;
//                 maxX = temp;
//             }
//
//             if (minY > maxY)
//             {
//                 float temp = minY;
//                 minY = maxY;
//                 maxY = temp;
//             }
//
//             // Define quad corners
//             Vector3 bl = new Vector3(minX, minY, z); // bottom-left
//             Vector3 tl = new Vector3(minX, maxY, z); // top-left
//             Vector3 br = new Vector3(maxX, minY, z); // bottom-right
//             Vector3 tr = new Vector3(maxX, maxY, z); // top-right
//
//             // First triangle (bl, tl, br)
//             int baseIndex = i * 6;
//             verts[baseIndex] = bl;
//             verts[baseIndex + 1] = tl;
//             verts[baseIndex + 2] = br;
//
//             // Second triangle (br, tl, tr)
//             verts[baseIndex + 3] = br;
//             verts[baseIndex + 4] = tl;
//             verts[baseIndex + 5] = tr;
//         }
//
//         return verts;
//     }
//
//     Vector4[] GenerateDummyColors(int vertCount)
//     {
//         // count = count * 6;
//         Vector4[] colors = new Vector4[vertCount];
//         for (int i = 0; i < vertCount; i++)
//         {
//             colors[i] = RandomColor();
//         }
//
//         return colors;
//     }
//
//
//     public void Update()
//     {
//         if (vertexBuffer != null && material != null)
//         {
//             // Larger bounds to ensure visibility
//             Bounds bounds = new Bounds(Vector3.zero, Vector3.one * 50f);
//
//             // Graphics.DrawProcedural(material, bounds, MeshTopology.Triangles, vertexCount);
//             Graphics.DrawProcedural(material, bounds, MeshTopology.Triangles, vertexBuffer.count);
//         }
//         else
//         {
//             print("Vertex Buffer or Material is null");
//         }
//     }
//
//
//     void OnDestroy()
//     {
//         vertexBuffer?.Release();
//         vertexColorBuffer?.Release();
//     }
//
//     public static Color RandomColor()
//     {
//         return new Color(
//             UnityEngine.Random.Range(0f, 1f), // Red component (0-1)
//             UnityEngine.Random.Range(0f, 1f), // Green component (0-1)
//             UnityEngine.Random.Range(0f, 1f), // Blue component (0-1)
//             1f // Alpha component (fully opaque)
//         );
//     }
//
//
//     Vector3[] SegmentsToVerts(Vector4[] segments)
//     {
//         // Filter out empty segments (segments with zero length or invalid data)
//         var validSegments = new System.Collections.Generic.List<Vector4>();
//
//         for (int i = 0; i < segments.Length; i++)
//         {
//             Vector4 segment = segments[i];
//             Vector3 start = new Vector3(segment.x, segment.y, 0);
//             Vector3 end = new Vector3(segment.z, segment.w, 0);
//
//             // Skip segments with zero length or invalid coordinates
//             if (Vector3.Distance(start, end) > 0.001f &&
//                 !float.IsNaN(segment.x) && !float.IsNaN(segment.y) &&
//                 !float.IsNaN(segment.z) && !float.IsNaN(segment.w))
//             {
//                 validSegments.Add(segment);
//             }
//         }
//
//         // Each segment becomes a quad (2 triangles = 6 vertices)
//         Vector3[] vertices = new Vector3[validSegments.Count * 6];
//         float lineWidth = 0.005f; // Adjust this to control line thickness
//
//         for (int i = 0; i < validSegments.Count; i++)
//         {
//             Vector4 segment = validSegments[i];
//             Vector3 start = new Vector3(segment.x, segment.y, 0);
//             Vector3 end = new Vector3(segment.z, segment.w, 0);
//
//             // Calculate perpendicular direction for line width
//             Vector3 direction = (end - start).normalized;
//             Vector3 perpendicular = new Vector3(-direction.y, direction.x, 0) * lineWidth * 0.5f;
//
//             // Calculate quad corners
//             Vector3 bl = start - perpendicular; // bottom-left
//             Vector3 tl = start + perpendicular; // top-left  
//             Vector3 br = end - perpendicular; // bottom-right
//             Vector3 tr = end + perpendicular; // top-right
//
//             // First triangle: bl, tl, br
//             int vertexIndex = i * 6;
//             vertices[vertexIndex + 0] = bl;
//             vertices[vertexIndex + 1] = tl;
//             vertices[vertexIndex + 2] = br;
//
//             // Second triangle: br, tl, tr
//             vertices[vertexIndex + 3] = br;
//             vertices[vertexIndex + 4] = tl;
//             vertices[vertexIndex + 5] = tr;
//         }
//
//         return vertices;
//     }
// }