#pragma kernel SeedFromSegments
#pragma kernel JumpFlood
#pragma kernel FinalizeSDF
#pragma kernel SeedFromScalarField

// Shared data structures
StructuredBuffer<float4> _Segments;
StructuredBuffer<int> _SegmentCount;
uint _TextureResolution;

// Seed generation outputs
RWTexture2D<float4> _SeedTexture; // RG = closest point world pos, B = segment ID, A = distance

// Jump flood ping-pong textures
Texture2D<float4> _InputTexture;
RWTexture2D<float4> _OutputTexture;
int _JumpDistance;

// Final SDF outputs
Texture2D<float4> _JFAResult;
RWTexture2D<float4> _SDFTexture;

// Optional for signed SDF
Texture2D<float> _ScalarField;
SamplerState sampler_ScalarField;
float _IsoValue;
bool _OutputUnsigned;
bool _HasScalarField;

// Helper function to find closest point on line segment
float2 ClosestPointOnSegment(float2 inputPoint, float2 a, float2 b, out float distance)
{
    float2 ab = b - a;
    float2 ap = inputPoint - a;
    float t = saturate(dot(ap, ab) / dot(ab, ab));
    float2 closest = a + t * ab;
    distance = length(inputPoint - closest);
    return closest;
}



[numthreads(8,8,1)]
void JumpFlood(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _TextureResolution || id.y >= _TextureResolution)
        return;
    
    float2 currentPos = (float2(id.xy) / float(_TextureResolution)) * 2.0f - 1.0f;
    float4 bestSeed = _InputTexture[id.xy];
    float bestDistance = bestSeed.a;
    
    // If we already have a valid seed, calculate its actual distance to current pixel
    if (bestDistance < 1e8)
    {
        float2 seedPos = bestSeed.xy;
        bestDistance = length(currentPos - seedPos);
    }
    
    // Check 9 neighbors at jump distance
    for (int dy = -1; dy <= 1; dy++)
    {
        for (int dx = -1; dx <= 1; dx++)
        {
            int2 samplePos = int2(id.xy) + int2(dx, dy) * _JumpDistance;
            
            // Clamp to texture bounds
            if (samplePos.x >= 0 && samplePos.x < (int)_TextureResolution &&
                samplePos.y >= 0 && samplePos.y < (int)_TextureResolution)
            {
                float4 neighborSeed = _InputTexture[samplePos];
                
                // Skip invalid seeds (distance >= 1e8 means no seed)
                if (neighborSeed.a < 1e8)
                {
                    float2 seedPos = neighborSeed.xy;
                    float dist = length(currentPos - seedPos);
                    
                    if (dist < bestDistance)
                    {
                        bestDistance = dist;
                        bestSeed = float4(seedPos.x, seedPos.y, neighborSeed.z, dist);
                    }
                }
            }
        }
    }
    
    _OutputTexture[id.xy] = bestSeed;
}

[numthreads(8,8,1)]
void FinalizeSDF(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _TextureResolution || id.y >= _TextureResolution)
        return;
    
    float4 jfaData = _JFAResult[id.xy];
    float distance = jfaData.a; // Always unsigned from JFA
    float segmentID = jfaData.z;
    
    if (_OutputUnsigned)
    {
        // Surface SDF: unsigned distance in R, always positive sign in G
        _SDFTexture[id.xy] = float4(distance, 1.0f, segmentID, 0);
    }
    else if (_HasScalarField)
    {
        // Band SDF: unsigned distance in R, computed sign in G
        float2 worldPos = (float2(id.xy) / float(_TextureResolution)) * 2.0f - 1.0f;
        float2 fieldUV = (worldPos + 1.0) * 0.5; // Convert [-1,1] to [0,1]
        float fieldValue = _ScalarField.SampleLevel(sampler_ScalarField, fieldUV, 0).r;
        
        float sign = (fieldValue < _IsoValue) ? 1.0f : -1.0f;
        
        // Format: R = unsigned distance, G = sign, B = segment ID, A = unused
        _SDFTexture[id.xy] = float4(distance, sign, segmentID, 0);
    }
    else
    {
        // Fallback: unsigned distance, positive sign
        _SDFTexture[id.xy] = float4(distance, 1.0f, segmentID, 0);
    }
}

[numthreads(8,8,1)]
void SeedFromSegments(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _TextureResolution || id.y >= _TextureResolution)
        return;
    
    int segmentCount = _SegmentCount[0];
    
    // Convert pixel to world space [-1, 1]
    float2 worldPos = (float2(id.xy) / float(_TextureResolution)) * 2.0f - 1.0f;
    
    float minDistance = 1e9;
    float2 closestPoint = float2(0, 0);
    uint closestSegmentID = 0;
    
    // Find closest point on any segment
    for (uint i = 0; i < (uint)segmentCount; i++)
    {
        float2 segmentStart = _Segments[i].xy;
        float2 segmentEnd = _Segments[i].zw;
        
        float dist;
        float2 closest = ClosestPointOnSegment(worldPos, segmentStart, segmentEnd, dist);
        
        if (dist < minDistance)
        {
            minDistance = dist;
            closestPoint = closest;
            closestSegmentID = i;
        }
    }
    
    // Store seed data: closest point in RG, segment ID in B, distance in A
    _SeedTexture[id.xy] = float4(closestPoint.x, closestPoint.y, (float)closestSegmentID, minDistance);
}


[numthreads(8,8,1)]
void SeedFromScalarField(uint3 id : SV_DispatchThreadID)
{
    // Boundary check for the high-resolution texture we are writing to
    if (id.x >= _TextureResolution || id.y >= _TextureResolution)
        return;

    // Calculate the normalized UV coordinate [0,1] for the current thread
    float2 uv = (float2(id.xy) + 0.5f) / float(_TextureResolution);

    // To find boundaries, we still need to compare neighbors.
    // We calculate the UV step size (the size of one pixel in UV space)
    // for the source (_ScalarField) texture.
    float2 scalarTexelSize;
    uint scalarWidth, scalarHeight;
    _ScalarField.GetDimensions(scalarWidth, scalarHeight);
    scalarTexelSize = 1.0 / float2(scalarWidth, scalarHeight);

    // Sample the scalar field at the current UV and its neighbors
    float val_tl = _ScalarField.SampleLevel(sampler_ScalarField, uv, 0).r;
    float val_tr = _ScalarField.SampleLevel(sampler_ScalarField, uv + float2(scalarTexelSize.x, 0), 0).r;
    float val_bl = _ScalarField.SampleLevel(sampler_ScalarField, uv + float2(0, scalarTexelSize.y), 0).r;

    bool inside_tl = val_tl < _IsoValue;
    bool inside_tr = val_tr < _IsoValue;
    bool inside_bl = val_bl < _IsoValue;

    // If the inside/outside state is different, this pixel is on the boundary.
    if (inside_tl != inside_tr || inside_tl != inside_bl)
    {
        // This is a boundary pixel. Its seed is its own position.
        // Convert the high-res integer ID to normalized UV, then to world space [-1, 1].
        float2 worldPos = (float2(id.xy) / float(_TextureResolution)) * 2.0 - 1.0;

        // Store: XY = closest point pos, Z=unused, W=distance (0 for a seed)
        _SeedTexture[id.xy] = float4(worldPos.x, worldPos.y, 0, 0);
    }
    else
    {
        // Not a boundary pixel. Give it "infinite" distance.
        _SeedTexture[id.xy] = float4(0, 0, 0, 1e9);
    }
}

#pragma kernel BuildSegmentGrid

// Grid parameters from C#
uint _GridResolution;
uint _MaxSegmentsPerCell;


// Output grid data structures
RWByteAddressBuffer _GridCounts; // Using Raw buffer for atomic operations
RWStructuredBuffer<uint> _GridIndices;
// StructuredBuffer<int> _SegmentCount;
// This kernel runs one thread per segment
[numthreads(256,1,1)]
void BuildSegmentGrid(uint3 id : SV_DispatchThreadID)
{
    uint segment_id = id.x;
    
    // Get the number of segments from the count buffer (assuming it's already copied)
    // Or, more simply, just check if we're out of bounds of the buffer
    uint numSegments = _SegmentCount[0]; // Read the actual count
    if (segment_id >= numSegments) return;

    // Get segment start and end points in world space [-1, 1]
    float2 p1 = _Segments[segment_id].xy;
    float2 p2 = _Segments[segment_id].zw;

    // Convert world space to grid coordinates [0, _GridResolution-1]
    int2 min_cell = (int2)floor((min(p1, p2) + 1.0) * 0.5 * _GridResolution);
    int2 max_cell = (int2)ceil((max(p1, p2) + 1.0) * 0.5 * _GridResolution);

    min_cell = max(0, min_cell);
    max_cell = min((int)_GridResolution - 1, max_cell);

    // Iterate over the grid cells this segment's bounding box covers
    for (int y = min_cell.y; y <= max_cell.y; y++)
    {
        for (int x = min_cell.x; x <= max_cell.x; x++)
        {
            // Get a flat index for the current grid cell
            uint cell_flat_index = y * _GridResolution + x;
            
            // Atomically increment the counter for this cell to get a unique local index
            uint local_index;
            _GridCounts.InterlockedAdd(cell_flat_index * 4, 1, local_index);

            // If we haven't exceeded the max segments for this cell, add our ID to the list
            if (local_index < _MaxSegmentsPerCell)
            {
                uint list_start_index = cell_flat_index * _MaxSegmentsPerCell;
                _GridIndices[list_start_index + local_index] = segment_id;
            }
        }
    }
}

#pragma kernel SeedFromSegments_SP
#pragma kernel FinalizeSDF_FromDense

// ... (keep all your existing kernels and helper functions like ClosestPointOnSegment)

//--------------------------------------------------------------------------------------
// KERNEL: SeedFromSegments_SP
// High-performance version of SeedFromSegments that uses the spatial grid.
//--------------------------------------------------------------------------------------
[numthreads(8,8,1)]
void SeedFromSegments_SP(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _TextureResolution || id.y >= _TextureResolution) return;

    float2 worldPos = ((float2(id.xy) + 0.5f) / _TextureResolution) * 2.0f - 1.0f;
    float min_dist_sq = 1e9;
    
    // Convert world position to grid coordinates to find our local cell
    int2 center_cell = (int2)((worldPos + 1.0) * 0.5 * _GridResolution);

    // Search our own cell and the 8 surrounding neighbors
    for (int dy = -1; dy <= 1; dy++)
    {
        for (int dx = -1; dx <= 1; dx++)
        {
            int2 cell_to_check = center_cell + int2(dx, dy);

            // Boundary check
            if (all(cell_to_check >= 0) && all(cell_to_check < _GridResolution))
            {
                uint cell_flat_index = cell_to_check.y * _GridResolution + cell_to_check.x;
                uint segment_count_in_cell = _GridCounts.Load(cell_flat_index * 4);
                uint list_start_index = cell_flat_index * _MaxSegmentsPerCell;

                // Loop through only the segments in this local cell
                for (uint i = 0; i < min(segment_count_in_cell, _MaxSegmentsPerCell); i++)
                {
                    uint segment_id = _GridIndices[list_start_index + i];
                    
                    float2 p1 = _Segments[segment_id].xy;
                    float2 p2 = _Segments[segment_id].zw;

                    // We don't need the distance output from this helper here
                    float discard_dist; 
                    float2 closest_on_seg = ClosestPointOnSegment(worldPos, p1, p2, discard_dist);
                    float dist_sq = dot(worldPos - closest_on_seg, worldPos - closest_on_seg);

                    if (dist_sq < min_dist_sq)
                    {
                        min_dist_sq = dist_sq;
                    }
                }
            }
        }
    }

    // The seed position is not needed, just the final distance.
    // We store the final, unsigned distance in the .w component of the seed texture.
    _SeedTexture[id.xy] = float4(0, 0, 0, sqrt(min_dist_sq));
}


//--------------------------------------------------------------------------------------
// KERNEL: FinalizeSDF_FromDense
// A simple kernel that takes the dense distance data from SeedFromSegments_SP,
// determines the sign, and writes the final SDF. Skips JFA.
//--------------------------------------------------------------------------------------
[numthreads(8,8,1)]
void FinalizeSDF_FromDense(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _TextureResolution || id.y >= _TextureResolution) return;

    // The precise, unsigned distance was calculated and stored in the seed texture's alpha channel
    float distance = _SeedTexture[id.xy].a;
    float sign = 1.0;

    // Determine the sign by sampling the original scalar field
    if (_HasScalarField)
    {
        float2 worldPos = ((float2(id.xy) + 0.5f) / _TextureResolution) * 2.0f - 1.0f;
        float2 uv = (worldPos + 1.0) * 0.5;
        float fieldValue = _ScalarField.SampleLevel(sampler_ScalarField, uv, 0).r;
        sign = (fieldValue < _IsoValue) ? -1.0 : 1.0;
    }

    // Write final signed distance to the output texture.
    _SDFTexture[id.xy] = float4(distance * sign, 0, 0, 1);
}