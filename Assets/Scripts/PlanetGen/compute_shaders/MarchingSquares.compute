#pragma kernel MarchingSquares

struct SegmentColor
{
    float4 color1;
    float4 color2;
};

float IsoValue;
int TextureWidth;
int TextureHeight;

Texture2D<float4> ScalarFieldTexture;
Texture2D<float4> ColorFieldTexture;
RWStructuredBuffer<float4> SegmentsBuffer;
RWStructuredBuffer<int> SegmentCountBuffer;
RWStructuredBuffer<SegmentColor> SegmentColorsBuffer;

float2 InterpolateEdge(float2 p1, float2 p2, float v1, float v2, float iso)
{
    if (abs(v1 - v2) < 0.001f) return p1;
    float t = (iso - v1) / (v2 - v1);
    return lerp(p1, p2, t);
}

float4 InterpolateColor(float4 c1, float4 c2, float v1, float v2,  float iso)
{
    if (abs(v1 -v2) < 0.001f) return c1;
    float t = (iso - v1) / (v2 - v1);
    return lerp(c1, c2, t);
}

[numthreads(8,8,1)]
void MarchingSquares(uint3 id : SV_DispatchThreadID)
{
    uint x = id.x;
    uint y = id.y;

    if (x >= TextureWidth - 1 || y >= TextureHeight - 1)
        return;

    // Sample the 4 corners of this cell
    float v00 = ScalarFieldTexture[uint2(x, y)].r; // bottom-left
    float v10 = ScalarFieldTexture[uint2(x + 1, y)].r; // bottom-right
    float v11 = ScalarFieldTexture[uint2(x + 1, y + 1)].r; // top-right
    float v01 = ScalarFieldTexture[uint2(x, y + 1)].r; // top-left

    // Sample the 4 corner colors
    float4 c00 = ColorFieldTexture[uint2(x, y)];
    float4 c10 = ColorFieldTexture[uint2(x + 1, y)];
    float4 c11 = ColorFieldTexture[uint2(x + 1, y + 1)];
    float4 c01 = ColorFieldTexture[uint2(x, y + 1)];
    

    // Create the case index (clockwise from bottom-left)
    int caseIndex = 0;
    if (v00 > IsoValue) caseIndex |= 1; // bottom-left
    if (v10 > IsoValue) caseIndex |= 2; // bottom-right
    if (v11 > IsoValue) caseIndex |= 4; // top-right
    if (v01 > IsoValue) caseIndex |= 8; // top-left

    // No contour if all points are on same side
    if (caseIndex == 0 || caseIndex == 15)
        return;

    // Cell positions normalized to [-1, 1] range
    float2 p00 = float2(x, y) / float2(TextureWidth - 1, TextureHeight - 1) * 2.0f - 1.0f;
    float2 p10 = float2(x + 1, y) / float2(TextureWidth - 1, TextureHeight - 1) * 2.0f - 1.0f;
    float2 p11 = float2(x + 1, y + 1) / float2(TextureWidth - 1, TextureHeight - 1) * 2.0f - 1.0f;
    float2 p01 = float2(x, y + 1) / float2(TextureWidth - 1, TextureHeight - 1) * 2.0f - 1.0f;

    // Edge positions with interpolation
    float2 edge0 = InterpolateEdge(p00, p10, v00, v10, IsoValue); // bottom edge
    float2 edge1 = InterpolateEdge(p10, p11, v10, v11, IsoValue); // right edge
    float2 edge2 = InterpolateEdge(p01, p11, v01, v11, IsoValue); // top edge
    float2 edge3 = InterpolateEdge(p00, p01, v00, v01, IsoValue); // left edge

    // Edge Colors with interpolation
    float4 color0 = InterpolateColor(c00, c10, v00, v10, IsoValue);
    float4 color1 = InterpolateColor(c10, c11, v10, v11, IsoValue);
    float4 color2 = InterpolateColor(c01, c11, v01, v11, IsoValue); // top edge
    float4 color3 = InterpolateColor(c00, c01, v00, v01, IsoValue); // left edge
    
    // Generate line segments with colors
    switch (caseIndex)
    {
    case 1: // bottom-left corner inside
        {
            int segmentIndex;
            InterlockedAdd(SegmentCountBuffer[0], 1, segmentIndex);
            SegmentsBuffer[segmentIndex] = float4(edge3, edge0);
            
            SegmentColor segColor;
            segColor.color1 = color3;
            segColor.color2 = color0;
            SegmentColorsBuffer[segmentIndex] = segColor;
            break;
        }
    case 2: // bottom-right corner inside
        {
            int segmentIndex;
            InterlockedAdd(SegmentCountBuffer[0], 1, segmentIndex);
            SegmentsBuffer[segmentIndex] = float4(edge0, edge1);
            
            SegmentColor segColor;
            segColor.color1 = color0;
            segColor.color2 = color1;
            SegmentColorsBuffer[segmentIndex] = segColor;
            break;
        }
    case 3: // bottom edge inside
        {
            int segmentIndex;
            InterlockedAdd(SegmentCountBuffer[0], 1, segmentIndex);
            SegmentsBuffer[segmentIndex] = float4(edge3, edge1);
            
            SegmentColor segColor;
            segColor.color1 = color3;
            segColor.color2 = color1;
            SegmentColorsBuffer[segmentIndex] = segColor;
            break;
        }
    case 4: // top-right corner inside
        {
            int segmentIndex;
            InterlockedAdd(SegmentCountBuffer[0], 1, segmentIndex);
            SegmentsBuffer[segmentIndex] = float4(edge1, edge2);
            
            SegmentColor segColor;
            segColor.color1 = color1;
            segColor.color2 = color2;
            SegmentColorsBuffer[segmentIndex] = segColor;
            break;
        }
    case 5: // bottom-left and top-right corners inside (saddle point)
        {
            int segIdx1, segIdx2;
            InterlockedAdd(SegmentCountBuffer[0], 2, segIdx1);
            segIdx2 = segIdx1 + 1;
            SegmentsBuffer[segIdx1] = float4(edge3, edge0);
            SegmentsBuffer[segIdx2] = float4(edge1, edge2);

            SegmentColor segColorA;
            segColorA.color1 = color3;
            segColorA.color2 = color0;
            SegmentColorsBuffer[segIdx1] = segColorA;

            SegmentColor segColorB;
            segColorB.color1 = color1;
            segColorB.color2 = color2;
            SegmentColorsBuffer[segIdx2] = segColorB;

            break;
        }
    case 6: // right edge inside
        {
            int segmentIndex;
            InterlockedAdd(SegmentCountBuffer[0], 1, segmentIndex);
            SegmentsBuffer[segmentIndex] = float4(edge0, edge2);
            
            SegmentColor segColor;
            segColor.color1 = color0;
            segColor.color2 = color2;
            SegmentColorsBuffer[segmentIndex] = segColor;
            break;
        }
    case 7: // bottom and right inside
        {
            int segmentIndex;
            InterlockedAdd(SegmentCountBuffer[0], 1, segmentIndex);
            SegmentsBuffer[segmentIndex] = float4(edge3, edge2);
            
            SegmentColor segColor;
            segColor.color1 = color3;
            segColor.color2 = color2;
            SegmentColorsBuffer[segmentIndex] = segColor;
            break;
        }
    case 8: // top-left corner inside
        {
            int segmentIndex;
            InterlockedAdd(SegmentCountBuffer[0], 1, segmentIndex);
            SegmentsBuffer[segmentIndex] = float4(edge2, edge3);
            
            SegmentColor segColor;
            segColor.color1 = color2;
            segColor.color2 = color3;
            SegmentColorsBuffer[segmentIndex] = segColor;
            break;
        }
    case 9: // left edge inside
        {
            int segmentIndex;
            InterlockedAdd(SegmentCountBuffer[0], 1, segmentIndex);
            SegmentsBuffer[segmentIndex] = float4(edge0, edge2);
            
            SegmentColor segColor;
            segColor.color1 = color0;
            segColor.color2 = color2;
            SegmentColorsBuffer[segmentIndex] = segColor;
            break;
        }
    case 10: // top-left and bottom-right corners inside (saddle point)
        {
            int segIdx1, segIdx2;
            InterlockedAdd(SegmentCountBuffer[0], 2, segIdx1);
            segIdx2 = segIdx1 + 1;
            SegmentsBuffer[segIdx1] = float4(edge0, edge1);
            SegmentsBuffer[segIdx2] = float4(edge2, edge3);
            
            SegmentColor segColorA;
            segColorA.color1 = color0;
            segColorA.color2 = color1;
            SegmentColorsBuffer[segIdx1] = segColorA;

            SegmentColor segColorB;
            segColorB.color1 = color2;
            segColorB.color2 = color3;
            SegmentColorsBuffer[segIdx2] = segColorB;
            break;
        }
    case 11: // left and bottom inside
        {
            int segmentIndex;
            InterlockedAdd(SegmentCountBuffer[0], 1, segmentIndex);
            SegmentsBuffer[segmentIndex] = float4(edge1, edge2);
            
            SegmentColor segColor;
            segColor.color1 = color1;
            segColor.color2 = color2;
            SegmentColorsBuffer[segmentIndex] = segColor;
            break;
        }
    case 12: // top edge inside
        {
            int segmentIndex;
            InterlockedAdd(SegmentCountBuffer[0], 1, segmentIndex);
            SegmentsBuffer[segmentIndex] = float4(edge1, edge3);
            
            SegmentColor segColor;
            segColor.color1 = color1;
            segColor.color2 = color3;
            SegmentColorsBuffer[segmentIndex] = segColor;
            break;
        }
    case 13: // left and top inside
        {
            int segmentIndex;
            InterlockedAdd(SegmentCountBuffer[0], 1, segmentIndex);
            SegmentsBuffer[segmentIndex] = float4(edge0, edge1);
            
            SegmentColor segColor;
            segColor.color1 = color0;
            segColor.color2 = color1;
            SegmentColorsBuffer[segmentIndex] = segColor;
            break;
        }
    case 14: // top and right inside
        {
            int segmentIndex;
            InterlockedAdd(SegmentCountBuffer[0], 1, segmentIndex);
            SegmentsBuffer[segmentIndex] = float4(edge0, edge3);
            
            SegmentColor segColor;
            segColor.color1 = color0;
            segColor.color2 = color3;
            SegmentColorsBuffer[segmentIndex] = segColor;
            break;
        }
    }
}