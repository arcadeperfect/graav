#pragma kernel MarchingSquaresContour

struct ContourVertex
{
    float3 position;
    float3 normal;
    float4 color;
};

struct Triangle
{
    ContourVertex v0;
    ContourVertex v1;
    ContourVertex v2;
};

float IsoValue;
int TextureWidth;
int TextureHeight;
float LineWidth; // Use a simple float for thickness

Texture2D<float>  ScalarFieldTexture;
Texture2D<float4> ColorFieldTexture;


AppendStructuredBuffer<Triangle> TriangleBuffer;


float2 InterpolateEdge(float2 p1, float2 p2, float v1, float v2, float iso)
{
    if (abs(v1 - v2) < 0.00001f) return p1;
    float t = (iso - v1) / (v2 - v1);
    return lerp(p1, p2, t);
}

float4 InterpolateColor(float4 c1, float4 c2, float v1, float v2, float iso)
{
    if (abs(v1 - v2) < 0.00001f) return c1;
    float t = (iso - v1) / (v2 - v1);
    return lerp(c1, c2, t);
}
//
// void AddContourSegment2(float4 pA_packed, float4 cA, float4 pB_packed, float4 cB)
// {
//     // Unpack the two points from pA_packed and pB_packed
//     float2 pA_inner = pA_packed.xy; // Point on IsoValue - LineWidth/2 contour
//     float2 pA_outer = pA_packed.zw; // Point on IsoValue + LineWidth/2 contour
//
//     float2 pB_inner = pB_packed.xy; // Point on IsoValue - LineWidth/2 contour
//     float2 pB_outer = pB_packed.zw; // Point on IsoValue + LineWidth/2 contour
//
//     ContourVertex v0, v1, v2, v3;
//
//     // These four vertices form a quad (a thick line segment)
//     // v0 and v1 are from point A (one end of the segment)
//     // v2 and v3 are from point B (the other end of the segment)
//
//     // Define the vertices for the quad:
//     //  v1 ----- v2
//     //  |        |
//     //  v0 ----- v3
//     // Assuming a segment from pA to pB.
//     // Let's define the quad vertices for the thick line segment.
//     // One side of the thick line (e.g., "inner" boundary)
//     v0.position = float3(pA_inner, 0.0f); // A's inner point
//     v0.normal = float3(0.0f, 0.0f, 1.0f); // Or a calculated normal if you need correct lighting
//     v0.color = cA;
//
//     v3.position = float3(pB_inner, 0.0f); // B's inner point
//     v3.normal = float3(0.0f, 0.0f, 1.0f);
//     v3.color = cB;
//
//     // The other side of the thick line (e.g., "outer" boundary)
//     v1.position = float3(pA_outer, 0.0f); // A's outer point
//     v1.normal = float3(0.0f, 0.0f, 1.0f);
//     v1.color = cA;
//
//     v2.position = float3(pB_outer, 0.0f); // B's outer point
//     v2.normal = float3(0.0f, 0.0f, 1.0f);
//     v2.color = cB;
//
//     // Now, form the two triangles that make up this quad.
//     // Ensure consistent winding order (e.g., clockwise or counter-clockwise)
//     // For example, triangle 1: v0, v1, v2
//     Triangle t1;
//     t1.v0 = v0;
//     t1.v1 = v1;
//     t1.v2 = v2; // This makes a triangle from inner A, outer A, outer B
//
//     TriangleBuffer.Append(t1);
//
//     // Triangle 2: v0, v2, v3
//     Triangle t2;
//     t2.v0 = v0;
//     t2.v1 = v2; // This makes a triangle from inner A, outer B, inner B
//     t2.v2 = v3;
//
//     TriangleBuffer.Append(t2);
// }
// // void AddContourSegment2(float4 pA, float4 cA, float4 pB, float4 cB)
// // {
// //     ContourVertex v0, v1, v2, v3;
// //
// //     v0.position = float3(pA.xy, 0.0f);
// //     v0.normal = float3(0.0f, 0.0f, 1.0f); // Assuming a flat surface
// //     v0.color = cA;
// //
// //     v1.position = float3(pA.yz, 0.0f);
// //     v1.normal = float3(0.0f, 0.0f, 1.0f);
// //     v1.color = cA;
// //
// //     v2.position = float3(pB.yz, 0.0f);
// //     v2.normal = float3(0.0f, 0.0f, 1.0f);
// //     v2.color = cB;
// //
// //     v3.position = float3(pB.xy, 0.0f);
// //     v3.normal = float3(0.0f, 0.0f, 1.0f);
// //     v3.color = cB;
// //
// //     Triangle t1;
// //     t1.v0 = v0;
// //     t1.v1 = v1;
// //     t1.v2 = v2;
// //     
// //     TriangleBuffer.Append(t1);
// //
// //     Triangle t2;
// //     t2.v0 = v0;
// //     t2.v1 = v2;
// //     t2.v2 = v3;
// //     
// //     TriangleBuffer.Append(t2);
// // }
//
// void AddContourSegment(float2 pA, float4 cA, float2 pB, float4 cB)
// {
//     // Calculate the segment direction and its perpendicular normal
//     float2 tangent = normalize(pB - pA);
//     float3 normal = float3(tangent.y, -tangent.x, 0.0f);
//
//     float halfWidth = LineWidth * 0.5f;
//
//     // Define the 4 vertices of the quad
//     ContourVertex v0, v1, v2, v3;
//
//     v0.position = float3(pA - normal.xy * halfWidth, 0.0f);
//     v0.normal = normal;
//     v0.color = cA;
//
//     v1.position = float3(pA + normal.xy * halfWidth, 0.0f);
//     v1.normal = normal;
//     v1.color = cA;
//
//     v2.position = float3(pB + normal.xy * halfWidth, 0.0f);
//     v2.normal = normal;
//     v2.color = cB;
//
//     v3.position = float3(pB - normal.xy * halfWidth, 0.0f);
//     v3.normal = normal;
//     v3.color = cB;
//
//     // Append the two triangles that form the quad.
//     // The order of appending defines the triangles.
//     // Triangle 1
//
//     Triangle t1;
//     t1.v0 = v0;
//     t1.v1 = v1;
//     t1.v2 = v2;
//     
//     TriangleBuffer.Append(t1);
//
//     Triangle t2;
//     t2.v0 = v0;
//     t2.v1 = v2;
//     t2.v2 = v3;
//     
//     TriangleBuffer.Append(t2);
//
// }
//
//
// [numthreads(8,8,1)]
// void MarchingSquaresContour(uint3 id : SV_DispatchThreadID)
// {
//     if (id.x >= TextureWidth - 1 || id.y >= TextureHeight - 1)
//         return;
//
//     // 1. SAMPLE CORNERS (Same as before)
//     float v00 = ScalarFieldTexture[id.xy].r;
//     float v10 = ScalarFieldTexture[id.xy + uint2(1, 0)].r;
//     float v11 = ScalarFieldTexture[id.xy + uint2(1, 1)].r;
//     float v01 = ScalarFieldTexture[id.xy + uint2(0, 1)].r;
//
//     float4 c00 = ColorFieldTexture[id.xy];
//     float4 c10 = ColorFieldTexture[id.xy + uint2(1, 0)];
//     float4 c11 = ColorFieldTexture[id.xy + uint2(1, 1)];
//     float4 c01 = ColorFieldTexture[id.xy + uint2(0, 1)];
//
//     // 2. COMPUTE CASE INDEX (Same as before)
//     int caseIndex = (v00 > IsoValue) | (v10 > IsoValue) << 1 | (v11 > IsoValue) << 2 | (v01 > IsoValue) << 3;
//     if (caseIndex == 0 || caseIndex == 15)
//         return;
//
//
//     // 3. INTERPOLATE EDGE CROSSINGS (Corrected)
//     float2 p00 = id.xy / float2(TextureWidth, TextureHeight) * 2.0f - 1.0f;
//     float2 p10 = (id.xy + float2(1, 0)) / float2(TextureWidth, TextureHeight) * 2.0f - 1.0f;
//     float2 p11 = (id.xy + float2(1, 1)) / float2(TextureWidth, TextureHeight) * 2.0f - 1.0f;
//     float2 p01 = (id.xy + float2(0, 1)) / float2(TextureWidth, TextureHeight) * 2.0f - 1.0f;
//
//     float4 edge0_col = InterpolateColor(c00, c10, v00, v10, IsoValue);
//     float4 edge1_col = InterpolateColor(c10, c11, v10, v11, IsoValue);
//     float4 edge2_col = InterpolateColor(c11, c01, v11, v01, IsoValue); // Top  
//     float4 edge3_col = InterpolateColor(c01, c00, v01, v00, IsoValue); // Left 
//
//     float2 edge0_pos_A = InterpolateEdge(p00, p10, v00, v10, IsoValue - LineWidth / 2); // Bottom
//     float2 edge0_pos_B = InterpolateEdge(p00, p10, v00, v10, IsoValue + LineWidth / 2);
//     float2 edge1_pos_A = InterpolateEdge(p10, p11, v10, v11, IsoValue - LineWidth / 2); // Right
//     float2 edge1_pos_B = InterpolateEdge(p10, p11, v10, v11, IsoValue + LineWidth / 2);
//     float2 edge2_pos_A = InterpolateEdge(p11, p01, v11, v01, IsoValue - LineWidth / 2); // Top
//     float2 edge2_pos_B = InterpolateEdge(p11, p01, v11, v01, IsoValue + LineWidth / 2);
//     float2 edge3_pos_A = InterpolateEdge(p01, p00, v01, v00, IsoValue - LineWidth / 2); // Left
//     float2 edge3_pos_B = InterpolateEdge(p01, p00, v01, v00, IsoValue + LineWidth / 2);
//
//     float4 edge0_pos = float4(edge0_pos_A, edge0_pos_B);
//     float4 edge1_pos = float4(edge1_pos_A, edge1_pos_B);
//     float4 edge2_pos = float4(edge2_pos_A, edge2_pos_B);
//     float4 edge3_pos = float4(edge3_pos_A, edge3_pos_B);
//     
//     switch (caseIndex)
//     {
//     case 1:  AddContourSegment2(edge3_pos, edge3_col, edge0_pos, edge0_col); break;
//     case 2:  AddContourSegment2(edge0_pos, edge0_col, edge1_pos, edge1_col); break;
//     case 3:  AddContourSegment2(edge3_pos, edge3_col, edge1_pos, edge1_col); break;
//     case 4:  AddContourSegment2(edge1_pos, edge1_col, edge2_pos, edge2_col); break;
//     case 5:  // Saddle
//         AddContourSegment2(edge3_pos, edge3_col, edge0_pos, edge0_col);
//         AddContourSegment2(edge1_pos, edge1_col, edge2_pos, edge2_col);
//         break;
//     case 6:  AddContourSegment2(edge0_pos, edge0_col, edge2_pos, edge2_col); break;
//     case 7:  AddContourSegment2(edge3_pos, edge3_col, edge2_pos, edge2_col); break;
//     case 8:  AddContourSegment2(edge2_pos, edge2_col, edge3_pos, edge3_col); break;
//     case 9:  AddContourSegment2(edge0_pos, edge0_col, edge2_pos, edge2_col); break;
//     case 10: // Saddle
//         AddContourSegment2(edge0_pos, edge0_col, edge1_pos, edge1_col);
//         AddContourSegment2(edge2_pos, edge2_col, edge3_pos, edge3_col);
//         break;
//     case 11: AddContourSegment2(edge1_pos, edge1_col, edge2_pos, edge2_col); break;
//     case 12: AddContourSegment2(edge1_pos, edge1_col, edge3_pos, edge3_col); break;
//     case 13: AddContourSegment2(edge0_pos, edge0_col, edge1_pos, edge1_col); break;
//     case 14: AddContourSegment2(edge0_pos, edge0_col, edge3_pos, edge3_col); break;
//         
//
//     }
//
//     
//
//     // switch (caseIndex)
//     // {
//     //     case 1:  AddContourSegment(edge3_pos, edge3_col, edge0_pos, edge0_col); break;
//     //     case 2:  AddContourSegment(edge0_pos, edge0_col, edge1_pos, edge1_col); break;
//     //     case 3:  AddContourSegment(edge3_pos, edge3_col, edge1_pos, edge1_col); break;
//     //     case 4:  AddContourSegment(edge1_pos, edge1_col, edge2_pos, edge2_col); break;
//     //     case 5:  // Saddle
//     //         AddContourSegment(edge3_pos, edge3_col, edge0_pos, edge0_col);
//     //         AddContourSegment(edge1_pos, edge1_col, edge2_pos, edge2_col);
//     //         break;
//     //     case 6:  AddContourSegment(edge0_pos, edge0_col, edge2_pos, edge2_col); break;
//     //     case 7:  AddContourSegment(edge3_pos, edge3_col, edge2_pos, edge2_col); break;
//     //     case 8:  AddContourSegment(edge2_pos, edge2_col, edge3_pos, edge3_col); break;
//     //     case 9:  AddContourSegment(edge0_pos, edge0_col, edge2_pos, edge2_col); break;
//     //     case 10: // Saddle
//     //         AddContourSegment(edge0_pos, edge0_col, edge1_pos, edge1_col);
//     //         AddContourSegment(edge2_pos, edge2_col, edge3_pos, edge3_col);
//     //         break;
//     //     case 11: AddContourSegment(edge1_pos, edge1_col, edge2_pos, edge2_col); break;
//     //     case 12: AddContourSegment(edge1_pos, edge1_col, edge3_pos, edge3_col); break;
//     //     case 13: AddContourSegment(edge0_pos, edge0_col, edge1_pos, edge1_col); break;
//     //     case 14: AddContourSegment(edge0_pos, edge0_col, edge3_pos, edge3_col); break;
//     // }
// }

// Calculate gradient magnitude at edge midpoint for better width estimation
float GetGradientMagnitude(uint2 baseCoord, float2 edgeDir)
{
    // Sample neighboring points to estimate gradient
    float2 offset = normalize(edgeDir) * 0.5f;
    uint2 coord1 = clamp(baseCoord + uint2(offset), uint2(0,0), uint2(TextureWidth-1, TextureHeight-1));
    uint2 coord2 = clamp(baseCoord - uint2(offset), uint2(0,0), uint2(TextureWidth-1, TextureHeight-1));
    
    float val1 = ScalarFieldTexture[coord1].r;
    float val2 = ScalarFieldTexture[coord2].r;
    
    return abs(val1 - val2) + 0.001f; // Add small epsilon to avoid division by zero
}

void AddContourSegmentDualIso(float4 pA_packed, float4 cA, float4 pB_packed, float4 cB)
{
    float2 pA_inner = pA_packed.xy;
    float2 pA_outer = pA_packed.zw;
    float2 pB_inner = pB_packed.xy;
    float2 pB_outer = pB_packed.zw;

    ContourVertex v0, v1, v2, v3;

    v0.position = float3(pA_inner, 0.0f);
    v0.normal = float3(0.0f, 0.0f, 1.0f);
    v0.color = cA;

    v1.position = float3(pA_outer, 0.0f);
    v1.normal = float3(0.0f, 0.0f, 1.0f);
    v1.color = cA;

    v2.position = float3(pB_outer, 0.0f);
    v2.normal = float3(0.0f, 0.0f, 1.0f);
    v2.color = cB;

    v3.position = float3(pB_inner, 0.0f);
    v3.normal = float3(0.0f, 0.0f, 1.0f);
    v3.color = cB;

    Triangle t1;
    t1.v0 = v0; t1.v1 = v1; t1.v2 = v2;
    TriangleBuffer.Append(t1);

    Triangle t2;
    t2.v0 = v0; t2.v1 = v2; t2.v2 = v3;
    TriangleBuffer.Append(t2);
}

[numthreads(8,8,1)]
void MarchingSquaresContour(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= TextureWidth - 1 || id.y >= TextureHeight - 1)
        return;

    // Sample corners
    float v00 = ScalarFieldTexture[id.xy].r;
    float v10 = ScalarFieldTexture[id.xy + uint2(1, 0)].r;
    float v11 = ScalarFieldTexture[id.xy + uint2(1, 1)].r;
    float v01 = ScalarFieldTexture[id.xy + uint2(0, 1)].r;

    float4 c00 = ColorFieldTexture[id.xy];
    float4 c10 = ColorFieldTexture[id.xy + uint2(1, 0)];
    float4 c11 = ColorFieldTexture[id.xy + uint2(1, 1)];
    float4 c01 = ColorFieldTexture[id.xy + uint2(0, 1)];

    int caseIndex = (v00 > IsoValue) | (v10 > IsoValue) << 1 | (v11 > IsoValue) << 2 | (v01 > IsoValue) << 3;
    if (caseIndex == 0 || caseIndex == 15)
        return;

    // Convert to normalized coordinates
    float2 p00 = (id.xy + float2(0, 0)) / float2(TextureWidth, TextureHeight) * 2.0f - 1.0f;
    float2 p10 = (id.xy + float2(1, 0)) / float2(TextureWidth, TextureHeight) * 2.0f - 1.0f;
    float2 p11 = (id.xy + float2(1, 1)) / float2(TextureWidth, TextureHeight) * 2.0f - 1.0f;
    float2 p01 = (id.xy + float2(0, 1)) / float2(TextureWidth, TextureHeight) * 2.0f - 1.0f;

    // Estimate gradient magnitudes for adaptive width scaling
    float grad0 = GetGradientMagnitude(id.xy, p10 - p00); // Bottom edge
    float grad1 = GetGradientMagnitude(id.xy + uint2(1,0), p11 - p10); // Right edge  
    float grad2 = GetGradientMagnitude(id.xy + uint2(1,1), p01 - p11); // Top edge
    float grad3 = GetGradientMagnitude(id.xy + uint2(0,1), p00 - p01); // Left edge

    // Scale width based on gradient - steeper gradients need smaller offsets
    float2 worldToNorm = 2.0f / float2(TextureWidth, TextureHeight);
    float baseWidth = LineWidth * max(worldToNorm.x, worldToNorm.y);
    
    float width0 = baseWidth / max(grad0, 0.001f);
    float width1 = baseWidth / max(grad1, 0.001f);
    float width2 = baseWidth / max(grad2, 0.001f);
    float width3 = baseWidth / max(grad3, 0.001f);

    // Interpolate edges with gradient-compensated widths
    float2 edge0_pos_A = InterpolateEdge(p00, p10, v00, v10, IsoValue - width0 * 0.5f);
    float2 edge0_pos_B = InterpolateEdge(p00, p10, v00, v10, IsoValue + width0 * 0.5f);
    float2 edge1_pos_A = InterpolateEdge(p10, p11, v10, v11, IsoValue - width1 * 0.5f);
    float2 edge1_pos_B = InterpolateEdge(p10, p11, v10, v11, IsoValue + width1 * 0.5f);
    float2 edge2_pos_A = InterpolateEdge(p11, p01, v11, v01, IsoValue - width2 * 0.5f);
    float2 edge2_pos_B = InterpolateEdge(p11, p01, v11, v01, IsoValue + width2 * 0.5f);
    float2 edge3_pos_A = InterpolateEdge(p01, p00, v01, v00, IsoValue - width3 * 0.5f);
    float2 edge3_pos_B = InterpolateEdge(p01, p00, v01, v00, IsoValue + width3 * 0.5f);

    float4 edge0_pos = float4(edge0_pos_A, edge0_pos_B);
    float4 edge1_pos = float4(edge1_pos_A, edge1_pos_B);
    float4 edge2_pos = float4(edge2_pos_A, edge2_pos_B);
    float4 edge3_pos = float4(edge3_pos_A, edge3_pos_B);

    // Interpolate colors
    float4 edge0_col = InterpolateColor(c00, c10, v00, v10, IsoValue);
    float4 edge1_col = InterpolateColor(c10, c11, v10, v11, IsoValue);
    float4 edge2_col = InterpolateColor(c11, c01, v11, v01, IsoValue);
    float4 edge3_col = InterpolateColor(c01, c00, v01, v00, IsoValue);

    switch (caseIndex)
    {
        case 1:  AddContourSegmentDualIso(edge3_pos, edge3_col, edge0_pos, edge0_col); break;
        case 2:  AddContourSegmentDualIso(edge0_pos, edge0_col, edge1_pos, edge1_col); break;
        case 3:  AddContourSegmentDualIso(edge3_pos, edge3_col, edge1_pos, edge1_col); break;
        case 4:  AddContourSegmentDualIso(edge1_pos, edge1_col, edge2_pos, edge2_col); break;
        case 5:  
            AddContourSegmentDualIso(edge3_pos, edge3_col, edge0_pos, edge0_col);
            AddContourSegmentDualIso(edge1_pos, edge1_col, edge2_pos, edge2_col);
            break;
        case 6:  AddContourSegmentDualIso(edge0_pos, edge0_col, edge2_pos, edge2_col); break;
        case 7:  AddContourSegmentDualIso(edge3_pos, edge3_col, edge2_pos, edge2_col); break;
        case 8:  AddContourSegmentDualIso(edge2_pos, edge2_col, edge3_pos, edge3_col); break;
        case 9:  AddContourSegmentDualIso(edge0_pos, edge0_col, edge2_pos, edge2_col); break;
        case 10: 
            AddContourSegmentDualIso(edge0_pos, edge0_col, edge1_pos, edge1_col);
            AddContourSegmentDualIso(edge2_pos, edge2_col, edge3_pos, edge3_col);
            break;
        case 11: AddContourSegmentDualIso(edge1_pos, edge1_col, edge2_pos, edge2_col); break;
        case 12: AddContourSegmentDualIso(edge1_pos, edge1_col, edge3_pos, edge3_col); break;
        case 13: AddContourSegmentDualIso(edge0_pos, edge0_col, edge1_pos, edge1_col); break;
        case 14: AddContourSegmentDualIso(edge0_pos, edge0_col, edge3_pos, edge3_col); break;
    }
}