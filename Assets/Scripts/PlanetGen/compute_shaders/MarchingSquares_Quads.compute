#pragma kernel MarchingSquaresContour

// --- Original Segment Data Structures ---
struct SegmentColor
{
    float4 color1;
    float4 color2;
};

// --- New Contour Quad Data Structures ---
struct ContourVertex
{
    float3 position; // xyz position (z can be 0, or a constant for height)
    float3 normal;   // xy = 2D normal (perpendicular to contour), z = 0
    float4 color;    // interpolated color at this vertex
};

// --- Global Parameters ---
float IsoValue;
int TextureWidth;
int TextureHeight;

// --- Input Textures ---
Texture2D<float4> ScalarFieldTexture;
Texture2D<float4> ColorFieldTexture;
Texture2D<float>  ThicknessTexture; // Per-cell thickness map

// --- Output Buffers (for RAW Segments) ---
RWStructuredBuffer<float4>       SegmentsBuffer       : register(u0); // Stores start.xy and end.xy of raw segments
RWStructuredBuffer<int>          SegmentCountBuffer   : register(u1); // Atomic counter for raw segments
RWStructuredBuffer<SegmentColor> SegmentColorsBuffer  : register(u2); // Colors for raw segments

// --- Output Buffers (for SMOOTH Contour Quads) ---
RWStructuredBuffer<ContourVertex> ContourVerticesBuffer : register(u3); // Stores all generated vertices for quads
RWStructuredBuffer<uint>         ContourIndicesBuffer  : register(u4); // Stores indices for triangles
RWStructuredBuffer<uint>         TotalVertexCountBuffer : register(u5); // Single uint for total quad vertices
RWStructuredBuffer<uint>         TotalIndexCountBuffer  : register(u6); // Single uint for total quad indices


// --- Helper Functions ---

float2 InterpolateEdge(float2 p1, float2 p2, float v1, float v2, float iso)
{
    if (abs(v1 - v2) < 0.001f) return p1;
    float t = (iso - v1) / (v2 - v1);
    return lerp(p1, p2, t);
}

float4 InterpolateColor(float4 c1, float4 c2, float v1, float v2,  float iso)
{
    if (abs(v1 -v2) < 0.001f) return c1;
    float t = (iso - v1) / (v2 - v1);
    return lerp(c1, c2, t);
}

// Helper to add a quad (2 triangles) to the output buffers for the smooth contour
void AddContourQuad(
    float2 pA, float4 cA, // Start point and color of the segment
    float2 pB, float4 cB, // End point and color of the segment
    float thickness,
    inout uint current_num_verts,
    inout uint current_num_indices,
    ContourVertex cell_verts[8], // Local array to stage vertices
    uint cell_indices[12]        // Local array to stage indices
) {
    float2 tangent = normalize(pB - pA);
    // Determine the normal (perpendicular vector).
    // Adjust the sign (+1 or -1) of the normal based on your desired winding order
    // and which side of the contour you want the "thickness" to extend.
    float3 normal = float3(tangent.y, -tangent.x, 0.0f); // Points to the "left" of the segment direction

    // Vertices for the quad strip
    //   V1 --- V2
    //   |      |
    //   V0 --- V3
    // (V0 corresponds to pA-offset, V1 to pA+offset, V2 to pB+offset, V3 to pB-offset)

    // V0: pA offset by -normal
    cell_verts[current_num_verts + 0].position = float3(pA - normal.xy * thickness * 0.5f, 0.0f); // Z = 0
    cell_verts[current_num_verts + 0].normal   = normal;
    cell_verts[current_num_verts + 0].color    = cA;

    // V1: pA offset by +normal
    cell_verts[current_num_verts + 1].position = float3(pA + normal.xy * thickness * 0.5f, 0.0f); // Z = 0
    cell_verts[current_num_verts + 1].normal   = normal;
    cell_verts[current_num_verts + 1].color    = cA;

    // V2: pB offset by +normal
    cell_verts[current_num_verts + 2].position = float3(pB + normal.xy * thickness * 0.5f, 0.0f); // Z = 0
    cell_verts[current_num_verts + 2].normal   = normal;
    cell_verts[current_num_verts + 2].color    = cB;

    // V3: pB offset by -normal
    cell_verts[current_num_verts + 3].position = float3(pB - normal.xy * thickness * 0.5f, 0.0f); // Z = 0
    cell_verts[current_num_verts + 3].normal   = normal;
    cell_verts[current_num_verts + 3].color    = cB;


    // Indices for two triangles forming the quad: (V0, V1, V2) and (V0, V2, V3)
    // Ensures consistent counter-clockwise winding.
    cell_indices[current_num_indices + 0] = current_num_verts + 0;
    cell_indices[current_num_indices + 1] = current_num_verts + 1;
    cell_indices[current_num_indices + 2] = current_num_verts + 2;

    cell_indices[current_num_indices + 3] = current_num_verts + 0;
    cell_indices[current_num_indices + 4] = current_num_verts + 2;
    cell_indices[current_num_indices + 5] = current_num_verts + 3;

    current_num_verts += 4;
    current_num_indices += 6;
}


[numthreads(8,8,1)]
void MarchingSquaresContour(uint3 id : SV_DispatchThreadID)
{
    uint x = id.x;
    uint y = id.y;

    if (x >= TextureWidth - 1 || y >= TextureHeight - 1)
        return;

    // Sample the 4 corners of this cell
    float v00 = ScalarFieldTexture[uint2(x, y)].r;     // bottom-left
    float v10 = ScalarFieldTexture[uint2(x + 1, y)].r;   // bottom-right
    float v11 = ScalarFieldTexture[uint2(x + 1, y + 1)].r; // top-right
    float v01 = ScalarFieldTexture[uint2(x, y + 1)].r;   // top-left

    // Sample the 4 corner colors
    float4 c00 = ColorFieldTexture[uint2(x, y)];
    float4 c10 = ColorFieldTexture[uint2(x + 1, y)];
    float4 c11 = ColorFieldTexture[uint2(x + 1, y + 1)];
    float4 c01 = ColorFieldTexture[uint2(x, y + 1)];
    
    // Create the case index (clockwise from bottom-left)
    int caseIndex = 0;
    if (v00 > IsoValue) caseIndex |= 1; // bottom-left (bit 0)
    if (v10 > IsoValue) caseIndex |= 2; // bottom-right (bit 1)
    if (v11 > IsoValue) caseIndex |= 4; // top-right (bit 2)
    if (v01 > IsoValue) caseIndex |= 8; // top-left (bit 3)

    // No contour if all points are on same side
    if (caseIndex == 0 || caseIndex == 15)
        return;

    // Get the per-cell thickness from the ThicknessTexture
    float thickness = ThicknessTexture.Load(int3(x, y, 0)).r; // Assuming R channel stores thickness

    // Cell positions normalized to [-1, 1] range
    float2 p00 = float2(x, y) / float2(TextureWidth - 1, TextureHeight - 1) * 2.0f - 1.0f;
    float2 p10 = float2(x + 1, y) / float2(TextureWidth - 1, TextureHeight - 1) * 2.0f - 1.0f;
    float2 p11 = float2(x + 1, y + 1) / float2(TextureWidth - 1, TextureHeight - 1) * 2.0f - 1.0f;
    float2 p01 = float2(x, y + 1) / float2(TextureWidth - 1, TextureHeight - 1) * 2.0f - 1.0f;

    // Edge positions with interpolation (check if edge is crossed before interpolating)
    float2 edge0_pos = ( (v00 > IsoValue) != (v10 > IsoValue) ) ? InterpolateEdge(p00, p10, v00, v10, IsoValue) : float2(0,0); // bottom edge
    float2 edge1_pos = ( (v10 > IsoValue) != (v11 > IsoValue) ) ? InterpolateEdge(p10, p11, v10, v11, IsoValue) : float2(0,0); // right edge
    float2 edge2_pos = ( (v01 > IsoValue) != (v11 > IsoValue) ) ? InterpolateEdge(p01, p11, v01, v11, IsoValue) : float2(0,0); // top edge
    float2 edge3_pos = ( (v00 > IsoValue) != (v01 > IsoValue) ) ? InterpolateEdge(p00, p01, v00, v01, IsoValue) : float2(0,0); // left edge

    // Edge Colors with interpolation (check if edge is crossed)
    float4 edge0_col = ( (v00 > IsoValue) != (v10 > IsoValue) ) ? InterpolateColor(c00, c10, v00, v10, IsoValue) : float4(0,0,0,0);
    float4 edge1_col = ( (v10 > IsoValue) != (v11 > IsoValue) ) ? InterpolateColor(c10, c11, v10, v11, IsoValue) : float4(0,0,0,0);
    float4 edge2_col = ( (v01 > IsoValue) != (v11 > IsoValue) ) ? InterpolateColor(c01, c11, v01, v11, IsoValue) : float4(0,0,0,0);
    float4 edge3_col = ( (v00 > IsoValue) != (v01 > IsoValue) ) ? InterpolateColor(c00, c01, v00, v01, IsoValue) : float4(0,0,0,0);
    
    // Local arrays to stage vertices and indices for the SMOOTH CONTOUR (quads)
    ContourVertex cell_quad_verts[8];    // Max 8 vertices (for two quads in saddle cases)
    uint cell_quad_indices[12];          // Max 12 indices (for two quads)
    uint num_quad_verts_in_cell = 0;
    uint num_quad_indices_in_cell = 0;

    // --- Generate RAW Segments and SMOOTH Contour Quads ---
    switch (caseIndex)
    {
    case 1: // bottom-left corner inside
        // Store RAW Segment
        {
            int segmentIndex;
            InterlockedAdd(SegmentCountBuffer[0], 1, segmentIndex);
            SegmentsBuffer[segmentIndex] = float4(edge3_pos, edge0_pos);
            SegmentColor segColor;
            segColor.color1 = edge3_col;
            segColor.color2 = edge0_col;
            SegmentColorsBuffer[segmentIndex] = segColor;
        }
        // Generate SMOOTH Contour Quad
        AddContourQuad(edge3_pos, edge3_col, edge0_pos, edge0_col, thickness, num_quad_verts_in_cell, num_quad_indices_in_cell, cell_quad_verts, cell_quad_indices);
        break;

    case 2: // bottom-right corner inside
        {
            int segmentIndex;
            InterlockedAdd(SegmentCountBuffer[0], 1, segmentIndex);
            SegmentsBuffer[segmentIndex] = float4(edge0_pos, edge1_pos);
            SegmentColor segColor;
            segColor.color1 = edge0_col;
            segColor.color2 = edge1_col;
            SegmentColorsBuffer[segmentIndex] = segColor;
        }
        AddContourQuad(edge0_pos, edge0_col, edge1_pos, edge1_col, thickness, num_quad_verts_in_cell, num_quad_indices_in_cell, cell_quad_verts, cell_quad_indices);
        break;

    case 3: // bottom edge inside
        {
            int segmentIndex;
            InterlockedAdd(SegmentCountBuffer[0], 1, segmentIndex);
            SegmentsBuffer[segmentIndex] = float4(edge3_pos, edge1_pos);
            SegmentColor segColor;
            segColor.color1 = edge3_col;
            segColor.color2 = edge1_col;
            SegmentColorsBuffer[segmentIndex] = segColor;
        }
        AddContourQuad(edge3_pos, edge3_col, edge1_pos, edge1_col, thickness, num_quad_verts_in_cell, num_quad_indices_in_cell, cell_quad_verts, cell_quad_indices);
        break;

    case 4: // top-right corner inside
        {
            int segmentIndex;
            InterlockedAdd(SegmentCountBuffer[0], 1, segmentIndex);
            SegmentsBuffer[segmentIndex] = float4(edge1_pos, edge2_pos);
            SegmentColor segColor;
            segColor.color1 = edge1_col;
            segColor.color2 = edge2_col;
            SegmentColorsBuffer[segmentIndex] = segColor;
        }
        AddContourQuad(edge1_pos, edge1_col, edge2_pos, edge2_col, thickness, num_quad_verts_in_cell, num_quad_indices_in_cell, cell_quad_verts, cell_quad_indices);
        break;

    case 5: // bottom-left and top-right corners inside (saddle point)
        // Store RAW Segments (2 segments)
        {
            int segIdx1, segIdx2;
            InterlockedAdd(SegmentCountBuffer[0], 2, segIdx1);
            segIdx2 = segIdx1 + 1;
            SegmentsBuffer[segIdx1] = float4(edge3_pos, edge0_pos);
            SegmentsBuffer[segIdx2] = float4(edge1_pos, edge2_pos);
            SegmentColor segColorA;
            segColorA.color1 = edge3_col; segColorA.color2 = edge0_col;
            SegmentColorsBuffer[segIdx1] = segColorA;
            SegmentColor segColorB;
            segColorB.color1 = edge1_col; segColorB.color2 = edge2_col;
            SegmentColorsBuffer[segIdx2] = segColorB;
        }
        // Generate SMOOTH Contour Quads (2 quads)
        AddContourQuad(edge3_pos, edge3_col, edge0_pos, edge0_col, thickness, num_quad_verts_in_cell, num_quad_indices_in_cell, cell_quad_verts, cell_quad_indices);
        AddContourQuad(edge1_pos, edge1_col, edge2_pos, edge2_col, thickness, num_quad_verts_in_cell, num_quad_indices_in_cell, cell_quad_verts, cell_quad_indices);
        break;

    case 6: // right edge inside
        {
            int segmentIndex;
            InterlockedAdd(SegmentCountBuffer[0], 1, segmentIndex);
            SegmentsBuffer[segmentIndex] = float4(edge0_pos, edge2_pos);
            SegmentColor segColor;
            segColor.color1 = edge0_col;
            segColor.color2 = edge2_col;
            SegmentColorsBuffer[segmentIndex] = segColor;
        }
        AddContourQuad(edge0_pos, edge0_col, edge2_pos, edge2_col, thickness, num_quad_verts_in_cell, num_quad_indices_in_cell, cell_quad_verts, cell_quad_indices);
        break;

    case 7: // bottom and right inside
        {
            int segmentIndex;
            InterlockedAdd(SegmentCountBuffer[0], 1, segmentIndex);
            SegmentsBuffer[segmentIndex] = float4(edge3_pos, edge2_pos);
            SegmentColor segColor;
            segColor.color1 = edge3_col;
            segColor.color2 = edge2_col;
            SegmentColorsBuffer[segmentIndex] = segColor;
        }
        AddContourQuad(edge3_pos, edge3_col, edge2_pos, edge2_col, thickness, num_quad_verts_in_cell, num_quad_indices_in_cell, cell_quad_verts, cell_quad_indices);
        break;

    case 8: // top-left corner inside
        {
            int segmentIndex;
            InterlockedAdd(SegmentCountBuffer[0], 1, segmentIndex);
            SegmentsBuffer[segmentIndex] = float4(edge2_pos, edge3_pos);
            SegmentColor segColor;
            segColor.color1 = edge2_col;
            segColor.color2 = edge3_col;
            SegmentColorsBuffer[segmentIndex] = segColor;
        }
        AddContourQuad(edge2_pos, edge2_col, edge3_pos, edge3_col, thickness, num_quad_verts_in_cell, num_quad_indices_in_cell, cell_quad_verts, cell_quad_indices);
        break;

    case 9: // left edge inside
        {
            int segmentIndex;
            InterlockedAdd(SegmentCountBuffer[0], 1, segmentIndex);
            SegmentsBuffer[segmentIndex] = float4(edge0_pos, edge2_pos); // This seems reversed, should be edge3_pos, edge0_pos then edge1_pos, edge2_pos
                                                                         // Given (v00,v10,v11,v01) and case 9 is (1001) means v00 and v01 are 'inside', so line from edge0 to edge2 is correct
            SegmentColor segColor;
            segColor.color1 = edge0_col;
            segColor.color2 = edge2_col;
            SegmentColorsBuffer[segmentIndex] = segColor;
        }
        AddContourQuad(edge0_pos, edge0_col, edge2_pos, edge2_col, thickness, num_quad_verts_in_cell, num_quad_indices_in_cell, cell_quad_verts, cell_quad_indices);
        break;

    case 10: // top-left and bottom-right corners inside (saddle point)
        // Store RAW Segments (2 segments)
        {
            int segIdx1, segIdx2;
            InterlockedAdd(SegmentCountBuffer[0], 2, segIdx1);
            segIdx2 = segIdx1 + 1;
            SegmentsBuffer[segIdx1] = float4(edge0_pos, edge1_pos);
            SegmentsBuffer[segIdx2] = float4(edge2_pos, edge3_pos);
            SegmentColor segColorA;
            segColorA.color1 = edge0_col; segColorA.color2 = edge1_col;
            SegmentColorsBuffer[segIdx1] = segColorA;
            SegmentColor segColorB;
            segColorB.color1 = edge2_col; segColorB.color2 = edge3_col;
            SegmentColorsBuffer[segIdx2] = segColorB;
        }
        // Generate SMOOTH Contour Quads (2 quads)
        AddContourQuad(edge0_pos, edge0_col, edge1_pos, edge1_col, thickness, num_quad_verts_in_cell, num_quad_indices_in_cell, cell_quad_verts, cell_quad_indices);
        AddContourQuad(edge2_pos, edge2_col, edge3_pos, edge3_col, thickness, num_quad_verts_in_cell, num_quad_indices_in_cell, cell_quad_verts, cell_quad_indices);
        break;

    case 11: // bottom and left inside
        {
            int segmentIndex;
            InterlockedAdd(SegmentCountBuffer[0], 1, segmentIndex);
            SegmentsBuffer[segmentIndex] = float4(edge1_pos, edge2_pos);
            SegmentColor segColor;
            segColor.color1 = edge1_col;
            segColor.color2 = edge2_col;
            SegmentColorsBuffer[segmentIndex] = segColor;
        }
        AddContourQuad(edge1_pos, edge1_col, edge2_pos, edge2_col, thickness, num_quad_verts_in_cell, num_quad_indices_in_cell, cell_quad_verts, cell_quad_indices);
        break;

    case 12: // top edge inside
        {
            int segmentIndex;
            InterlockedAdd(SegmentCountBuffer[0], 1, segmentIndex);
            SegmentsBuffer[segmentIndex] = float4(edge1_pos, edge3_pos);
            SegmentColor segColor;
            segColor.color1 = edge1_col;
            segColor.color2 = edge3_col;
            SegmentColorsBuffer[segmentIndex] = segColor;
        }
        AddContourQuad(edge1_pos, edge1_col, edge3_pos, edge3_col, thickness, num_quad_verts_in_cell, num_quad_indices_in_cell, cell_quad_verts, cell_quad_indices);
        break;

    case 13: // left and top inside
        {
            int segmentIndex;
            InterlockedAdd(SegmentCountBuffer[0], 1, segmentIndex);
            SegmentsBuffer[segmentIndex] = float4(edge0_pos, edge1_pos);
            SegmentColor segColor;
            segColor.color1 = edge0_col;
            segColor.color2 = edge1_col;
            SegmentColorsBuffer[segmentIndex] = segColor;
        }
        AddContourQuad(edge0_pos, edge0_col, edge1_pos, edge1_col, thickness, num_quad_verts_in_cell, num_quad_indices_in_cell, cell_quad_verts, cell_quad_indices);
        break;

    case 14: // top and right inside
        {
            int segmentIndex;
            InterlockedAdd(SegmentCountBuffer[0], 1, segmentIndex);
            SegmentsBuffer[segmentIndex] = float4(edge0_pos, edge3_pos);
            SegmentColor segColor;
            segColor.color1 = edge0_col;
            segColor.color2 = edge3_col;
            SegmentColorsBuffer[segmentIndex] = segColor;
        }
        AddContourQuad(edge0_pos, edge0_col, edge3_pos, edge3_col, thickness, num_quad_verts_in_cell, num_quad_indices_in_cell, cell_quad_verts, cell_quad_indices);
        break;
    }

    // --- Write SMOOTH Contour Quads to Global Buffers ---
    if (num_quad_verts_in_cell > 0)
    {
        uint global_vertex_start_idx = 0;
        InterlockedAdd(TotalVertexCountBuffer[0], num_quad_verts_in_cell, global_vertex_start_idx);

        uint global_index_start_idx = 0;
        InterlockedAdd(TotalIndexCountBuffer[0], num_quad_indices_in_cell, global_index_start_idx);

        // Write vertices
        for (uint i = 0; i < num_quad_verts_in_cell; ++i)
        {
            ContourVerticesBuffer[global_vertex_start_idx + i] = cell_quad_verts[i];
        }

        // Write indices (relative to the global vertex start index)
        for (uint i = 0; i < num_quad_indices_in_cell; ++i)
        {
            ContourIndicesBuffer[global_index_start_idx + i] = global_vertex_start_idx + cell_quad_indices[i];
        }
    }
}